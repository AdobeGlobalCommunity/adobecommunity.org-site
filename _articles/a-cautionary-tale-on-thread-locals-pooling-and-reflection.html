---
layout: article
title: 'A cautionary tale on thread locals, pooling and reflection'
tags:
  - 'Apache Sling'
original: 'https://rombertw.wordpress.com/2018/01/28/a-cautionary-tale-on-thread-locals-pooling-and-reflection/'
image: 'https://sling.apache.org/res/logos/sling.svg'
author: 'Robert Munteanu'
date: 2018-01-28T11:00:00.000Z
---

<p>Most non-trivial Java applications use thread pools to improve performance by avoiding thread creation and optionally by limiting the maximum numbers of threads in use.</p>
<p>The end goal is for each task to execute in a dedicated thread, without it being aware that the thread is not a fresh one, but was used before. Starting with Java 5 the Java runtime libraries offer a wealth of options for creating thread pools in the java.util.concurrent package.</p>
<p>So far, all is well &ndash; we have a simple, robust way of adding thread pooling to our application. That is, unless we are running code which is out of our control and is misbehaving. One kind of particularly subtle misbehaviour is using&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html" target="_blank" rel="noopener">ThreadLocal</a>&nbsp;storage and never cleaning that up. If you&rsquo;re not familiar with thread-local storage in Java, this kind of access allows each thread to store its own value for a certain variable. The example below comes straight from the javadoc.</p>